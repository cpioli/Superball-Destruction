(UPDATE: 8/24/2018):

SD doesn't work because the player cannot predict where the ball will go after the 2nd collision whether the superball's AI is turned on or not. I don't think the use of reaiming surfaces can be that effective because that mechanic suffers the same issue: beyond the 2nd collision the player can't tell what's happening or is able to predict what could happen. The player's choices to aim the ball and fire it had no impact on the ball's itinerary or the final score, and although the collisions were sort of funny the ball and physics did not exhibit a pattern the player could deduce. As a result the game in this state is more of a toy than a game, which is what I was afraid would happen.

In terms of graphics and effects, I had no time to build the destructible objects or find music. I had begun splicing up "In the Hall of the Mountain King" so I could swap between different parts of the music when speed and destruction escalated or de-escalated. Destructible objects could be made and I could swap between the two sets of meshes, but that would have also taken more time than I could afford.

The outstanding bugs involving collision detection and superball AI exacerbate the issues I have with the game, but the biggest setback was that Visual Studio couldn't debug the code because the build began failing due to missing scripts and assemblies due to an issue with the upgrade of ProBuilder (i.e. I switched from dragging the ProBuilder components into Unity to using the package manager). This hindered my progress a lot.

It's sad because the game took a lot of time to make! Fixing bugs, learning new tech, all of that just made it too hard. I should track the # of days I put into it and looks like 31 days * an average of 3 hours per day = 93 hours or 2 work weeks + 13 hours. I need to put more hours into the games per day and work on them consistently, failure or not. Otherwise I won't be able to do this enough and get the experience I need.

If the game were redesigned to allow the player to select new objects for the ball to target every (n < 5) collisions it might become a better game because then the game becomes "Can the player keep a rally going between breakable objects?" by leveraging knowledge of the ball's AI and basic physics. Then the "go bananas" aspect of the game begins if the player keeps a long enough rally or increases speed to a certain value.

It took so long to get to this point I am unsure if I can change it. The work to allow the player to point/click a breakable object to make the ball work in that direction requires better camera controls, highlighting borders of an object (cel-shading?), and a bunch of other features I haven't thought out. The best idea is to get to work on a new game or play around with the 3d kit Unity provided.


(ORIGINAL: 7/30/2018):
Why I don't think Superball Destruction works:

Typically I keep a vision in my head of how I expect the completed game to play: things like sound, graphics, effects, and the reaction of the player.

I began noticing my visualizations are just the fun parts and lack the glue that keeps things together. In Superball Destruction I can see individual moments being totally hilarious and amazing, but because part of the fun is in the unexpected crashes, players lose a lot of agency and control. I could see the player surprised by unexpected collisions and blowing out the side wall into the next room, getting excited by laying out a perfect plan for the superball, etc. But what happens when you aim and miss? What happens when the player must wait for the ball to slow down? 

I still believe in this idea, but exploring it further I can't see how it can work out. I still have to regulate the ball's velocity and re-implement gravity after its speed decreases to a particular value. I also have to implement cameras. I'll need a new layer of colliders for camera AI.

======

Full summary for portfolio:

The idea was to build a game that recreated the scene in Men In Black where J touches the yellow orb and it bounced off of every surface in the base, in particular destroying all the glass flasks in their lab. The design I wanted to begin with would shoot the ball out of a small cannon into a room filled with plates, and every time it hit a plate it would increase its speed slightly, every time it hit a wall or a shelf it would decrease in speed until it fell to the ground. Key points where I wanted players to feel the "height of enjoyment" would be moments where the ball went so fast it could hit objects 100ft away from each other, pushing over really large objects like giant urns and statues, even breaking through brick walls and making entire floors collapse.

I created a first-person view with corresponding mouse controls, an aiming reticule, and put the player in a small room they could shoot in to their hearts' content. The biggest issues were the following, and a few solutions I came up with:

1. There's no real way for the player to predict the trajectory of the ball after the first collision. I created a mesh with a shader that "tweened" a line of arrows in the direction the player was aiming, and an additional texture would point in the direction the ball would have when it bounced off the first surface the ball collided with. This is only one collision, but the tool provided a visual aid players could use to figure out potential 2nd and 3rd collisions.
2. If the player can't see what's happening, there's no fun. A dynamic camera system would be necessary to view all the action, which means a lot of panning, a lot of zooming, a lot of movement.
3. The physics engine did not want to cooperate with me and would cancel a component of the velocity after a collision, sometimes two components. The only way to change that was 
4. Players had no control over the ball after it was shot. As a result, the game was 5% player decision and 95% watch things break. I figured I'd color and shape particular plates that - when the ball came in contact with it - would allow the player to re-aim and shoot the ball. Placing these in spots throughout the environment. One of the problems with this is there is still no guarantee the ball will try to hit it.

I added a simple AI to the ball that would override the physics engine by changing the ball's direction to hit the nearest breakable object. This would prevent the dampening of component vectors and if polished could make it easier for players to predict the trajectory of the ball after 4 or 5 collisions, and hopefully satisfying the player's need for control.

After two weeks worth of work, my prototype was sadly not fun.