# Superball-Destruction

This was an attempt to make a set of game mechanics that turned a rubber superball into an object players could throw in a room filled with objects. The game wasn't that fun, though, and I had to shelve it after several iterations.

In this game, the player aims a cannon and fires it at ceramic plates in a small room. If the ball hits a breakable object its velocity will increase. If it hits an unbreakable object, its velocity decreases. Once the superball's velocity reaches a value less than 5mph, the ball's velocity becomes influenced by gravity. The game ends when the y-component of the ball's velocity is <= 0.0f. Your score is the number of breakable objects you hit x 100.

The aesthetic is simple: breaking imaginary things is fun! (real things? Not so much)

In terms of programming, it was a decent success. I created a shader and texture that displays the ball's trajectory when it's shot out of the cannon, I used Unity3D's physics system to rewrite the rules of physics for the superball, I learned how to use Unity's EventManagement system (which made scripting much easier), and I learned how to use Quaternions.

However, I need to discuss the game's shortcomings. Simply put, it was not fun. Here I will present a list of its problems:

Problem 1: There's no real way for the player to predict the trajectory of the ball after the first collision, hence the player will never be able to establish a relationship between their input and the outcomes of their choices. When a player begins a game, they must first establish the rules that govern the game, then iteratively take new approaches to completing the game's challenge, and the player must have "faith" that the game's rules will be obeyed consistently. If the player cannot ascertain the relationships between systems, it stops being a game and becomes a toy or a technical demo.

First fix to Problem 1: I created a pair of meshes whose texture popped out of the cannon and tweened forward towards the targeted object. And whatever object the mesh "collided" with, the second mesh would be oriented in the trajectory of the bounce. This was to help the player understand the physical rules governing the game and let the player know how the first collision will work. It was a nice idea, and an especially helpful debugging tool, but sadly one collision does not mean much when the next four or five could result in a quick game over.

Second fix to Problem 1: add an AI to the superball that caused it to change its direction the moment it exited a collision (if it was pointed at an unbreakable object). It would try its hardest to redirect itself to a trajectory that would hit a breakable object, keeping up the momentum of crashes, increasing the ball's duration-of-flight. The ball has a field of view of n-degrees (shaped like a cone), and its range of movement was a cone of m degrees (where m < n).

This fix was an interesting challenge to implement, and the results were decent in a few cases: the ball could orient itself to hit a bunch of plates, and was smart enough to align itself to destroy entire rows of plates at a time. When it doesn't work, though, it's even more unpredictable. In cases where the nearest breakable object is outside the ball's range of movement, the ball will change its trajectory to so it collides with an object as close to the breakable object as possible, which may cause the ball to move in directions that move the ball further away from breakable objects. The robustness of the AI could be improved in future iterations.

Problem 2: Players' interaction with the game ends once they shoot the ball. As a result, the game was 5% player decision and 95% watch things break, which in most cases is not terribly fun. There might be ways to fix this, and I have experimented with a few:

First fix to Problem 2: Designate some breakable objects with a "Re-aiming" trait. When the ball collides with a breakable object assigned the Re-aiming script, the ball will freeze-in-place, and the player earns the chance to reaim the ball from the breakable object's position. With this, the player has more chances to interact with the game in that 95% of non-playtime. My biggest concern was that since players could not predict the ball's trajectory beyond 2 collisions, the frequency this mechanic will become available in each level would be random.

There were several other fixes I intended to implement to Problem 2. The most interesting one was an item called a "gravity well", that the player would put on the map before firing the cannon. A gravity well would be placed in the level, and if the ball's trajectory brought it close enough to the gravity well, it would pull the ball into its "black hole", then spit it out in the direction specified by the player at the beginning of the game.

This would have added an interesting mechanic to the game: the player would have a limited number of gravity wells, and to get the maximum usage out of them (i.e. increase the number of broken objects) the player would have to anticipate the sections of the level where the ball would not reach based on player input. And that's where the idea falls apart: as described in Problem 1, the player cannot predict the outcome no matter what position or in what orientation the cannon is. Without a reliable system to plan against, the player is unable to "strategize" the placement of gravity wells.
